<!DOCTYPE html>
<!-- Cache buster: 2025-01-28-05:30 -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCG Card Manager v2.1</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #64748b;
            --success-color: #059669;
            --warning-color: #d97706;
            --danger-color: #dc2626;
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        body {
            background-color: #f8fafc;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .main-header {
            background: linear-gradient(135deg, var(--primary-color) 0%, #1e40af 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
        }

        .card {
            border: none;
            box-shadow: var(--card-shadow);
            border-radius: 12px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px -5px rgba(0, 0, 0, 0.1);
        }

        .btn {
            border-radius: 8px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn-primary:hover {
            background-color: #1d4ed8;
            border-color: #1d4ed8;
        }

        .search-container {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--card-shadow);
        }

        .card-result {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .card-result:hover {
            border-color: var(--primary-color);
            background-color: #f8fafc;
        }

        .card-result.selected {
            border-color: var(--primary-color);
            background-color: #eff6ff;
            border-width: 2px;
        }

        .card-image {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .inventory-table {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: var(--card-shadow);
        }

        .inventory-table .table-responsive {
            max-height: 500px;
            overflow-y: auto;
        }

        .inventory-table .table thead th {
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
        }

        .table th {
            background-color: #f8fafc;
            border-bottom: 2px solid #e2e8f0;
            font-weight: 600;
            color: var(--secondary-color);
        }

        .loading-spinner {
            display: none;
        }

        .loading-spinner.show {
            display: block;
        }

        .status-message {
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--secondary-color);
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .sortable {
            cursor: pointer;
            position: relative;
            user-select: none;
        }

        .sortable:hover {
            background-color: #e9ecef;
        }

        .sortable .sort-icon::after {
            content: 'â†•';
            position: absolute;
            right: 8px;
            opacity: 0.5;
        }

        .sortable.sort-asc .sort-icon::after {
            content: 'â†‘';
            opacity: 1;
        }

        .sortable.sort-desc .sort-icon::after {
            content: 'â†“';
            opacity: 1;
        }

        .table-container {
            max-height: 600px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="main-header">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="mb-2"><i class="fas fa-cards-blank me-2"></i>TCG Card Manager v2</h1>
                    <p class="mb-0 opacity-75">Clean, modern card collection management</p>
                    <small class="text-muted">
                        <i class="fas fa-clock me-1"></i>Published: <span id="publishTimestamp"></span>
                    </small>
                </div>
                <div class="col-md-4 text-end">
                    <button class="btn btn-outline-light btn-sm me-2" onclick="importInventory()">
                        <i class="fas fa-upload me-1"></i>Import CSV
                    </button>
                    <button class="btn btn-warning btn-sm me-2" onclick="importPrices()">
                        <i class="fas fa-dollar-sign me-1"></i>Import Prices
                    </button>
                    <button class="btn btn-primary btn-sm me-2" onclick="updateAllPrices()">
                        <i class="fas fa-calculator me-1"></i>Update Prices
                    </button>
                    <button class="btn btn-success btn-sm" onclick="exportInventory()">
                        <i class="fas fa-download me-1"></i>Export CSV
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Search Section -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="search-container">
                    <h4 class="mb-3"><i class="fas fa-search me-2"></i>Search Cards</h4>
                    <div class="input-group mb-3">
                        <input type="text" id="searchInput" class="form-control form-control-lg" 
                               placeholder="Enter card name..." onkeypress="handleSearchKeypress(event)">
                        <button class="btn btn-primary btn-lg" onclick="searchCards()">
                            <i class="fas fa-search"></i>
                        </button>
                    </div>
                    
                    <!-- Loading Spinner -->
                    <div class="loading-spinner text-center" id="loadingSpinner">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-2 text-muted">Searching cards...</p>
                    </div>

                    <!-- Search Results -->
                    <div id="searchResults">
                        <div class="empty-state">
                            <i class="fas fa-search"></i>
                            <h5>Search for Magic cards</h5>
                            <p>Enter a card name to get started</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Inventory Section -->
        <div class="row">
            <div class="col-12">
                <div class="inventory-table">
                    <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                        <h4 class="mb-0"><i class="fas fa-box me-2"></i>Your Inventory</h4>
                        <span class="badge bg-light text-dark" id="inventoryCount">0 cards</span>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-hover mb-0">
                                <thead>
                                    <tr>
                                        <th class="sortable" data-sort="name">Name <span class="sort-icon"></span></th>
                                        <th class="sortable" data-sort="set">Set <span class="sort-icon"></span></th>
                                        <th class="sortable" data-sort="number">Collector # <span class="sort-icon"></span></th>
                                        <th class="sortable" data-sort="condition">Condition <span class="sort-icon"></span></th>
                                        <th class="sortable" data-sort="foil">Foil <span class="sort-icon"></span></th>
                                        <th class="sortable" data-sort="quantity">Qty <span class="sort-icon"></span></th>
                                        <th class="sortable" data-sort="marketPrice">Market Price <span class="sort-icon"></span></th>
                                        <th class="sortable" data-sort="lowPrice">Low Price <span class="sort-icon"></span></th>
                                        <th class="sortable" data-sort="lowShipping">Low w/ Shipping <span class="sort-icon"></span></th>
                                        <th class="sortable" data-sort="originalPrice">Original Price <span class="sort-icon"></span></th>
                                        <th class="sortable" data-sort="calculatedPrice">Calculated Price <span class="sort-icon"></span></th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="inventoryTableBody">
                                    <tr>
                                        <td colspan="12">
                                            <div class="empty-state">
                                                <i class="fas fa-box-open"></i>
                                                <h5>No cards in inventory</h5>
                                                <p>Search and add cards to get started</p>
                                            </div>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal fade" id="importModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Import Inventory</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="csvFile" class="form-label">Select CSV File</label>
                        <input type="file" class="form-control" id="csvFile" accept=".csv">
                    </div>
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>TCG Export Format:</strong> Will use TCG Marketplace Price (not Market Price)<br>
                        <strong>Standard Format:</strong> Card Name, Set, Condition, Quantity, Price
                    </div>
                    <div class="form-check mb-3">
                        <input class="form-check-input" type="checkbox" id="clearExistingInventory" checked>
                        <label class="form-check-label" for="clearExistingInventory">
                            Clear existing inventory before import
                        </label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="processImport()">
                        <i class="fas fa-upload me-1"></i>Import
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Papa Parse for CSV handling -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <script>
        // Application State
        let inventory = [];
        let selectedCard = null;
        let searchResults = [];
        let priceData = []; // Store imported pricing data
        let currentSortField = 'name';
        let currentSortDirection = 'asc';

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            // Set local timestamp for debugging
            const now = new Date();
            const timestamp = now.toLocaleString('en-US', {
                year: 'numeric',
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            document.getElementById('publishTimestamp').textContent = timestamp;
            
            // Add sorting event listeners
            document.querySelectorAll('.sortable').forEach(header => {
                header.addEventListener('click', function() {
                    const field = this.getAttribute('data-sort');
                    handleSort(field);
                });
            });
            
            loadInventoryFromStorage();
            loadPriceData(); // Load pricing data on startup
            updateInventoryDisplay();
            updateSortIcons(); // Initialize sort icons
        });

        // ===== PHASE 1: UTILITY FUNCTIONS =====
        
        /**
         * Extract base collector number by removing foil suffixes
         * @param {string} collectorNumber - Original collector number (e.g., "319â˜…", "83F")
         * @returns {string} - Base collector number (e.g., "319", "83")
         */
        function getBaseCollectorNumber(collectorNumber) {
            if (!collectorNumber) return '';
            return String(collectorNumber).replace(/[â˜…â˜†*F]/g, '').trim();
        }

        /**
         * Select representative card from a group, preferring non-foil variants
         * @param {Array} cardGroup - Array of cards with same base collector number
         * @returns {Object} - Representative card object
         */
        function getRepresentativeCard(cardGroup) {
            if (!cardGroup || cardGroup.length === 0) return null;
            
            // Prefer non-foil cards (those without foil indicators in collector number)
            const nonFoilCard = cardGroup.find(card => {
                const collectorNum = card.collector_number || '';
                return !collectorNum.includes('â˜…') && !collectorNum.includes('â˜†') && !collectorNum.includes('*');
            });
            
            return nonFoilCard || cardGroup[0];
        }

        /**
         * Check if a set name indicates a promo set
         * @param {string} setName - Set name to check
         * @returns {boolean} - True if promo set
         */
        function isPromoSet(setName) {
            if (!setName) return false;
            return setName.toLowerCase().includes('promo');
        }

        /**
         * Generate set name variations for matching, excluding promo cross-matching
         * @param {string} setName - Original set name
         * @returns {Array} - Array of set name variations
         */
        function generateSetVariations(setName) {
            if (!setName || isPromoSet(setName)) {
                return []; // Promo sets don't get variations
            }
            
            const variations = [
                setName.replace('Seventh Edition', '7th Edition'),
                setName.replace('7th Edition', 'Seventh Edition'),
                setName.replace('Core Set ', ''),
                setName.replace(' Edition', ''),
                setName.replace('2020', 'Core Set 2020'),
                setName.replace('2021', 'Core Set 2021'),
                setName.replace('Magic 2010', 'M10'),
                setName.replace('Magic 2011', 'M11'),
                setName.replace('Magic 2012', 'M12'),
                setName.replace('Magic 2013', 'M13'),
                setName.replace('Magic 2014', 'M14'),
                setName.replace('Magic 2015', 'M15')
            ];
            
            // Filter out original name and any promo variations
            return variations.filter(v => v !== setName && !isPromoSet(v));
        }

        /**
         * Deduplicate foil variants by grouping cards by base collector number
         * @param {Array} cards - Array of card objects
         * @returns {Object} - Object with baseNumber as keys, card arrays as values
         */
        function deduplicateFoilVariants(cards) {
            const groups = {};
            
            cards.forEach(card => {
                const baseNumber = getBaseCollectorNumber(card.collector_number);
                if (!groups[baseNumber]) {
                    groups[baseNumber] = [];
                }
                groups[baseNumber].push(card);
            });
            
            return groups;
        }

        // Search functionality
        function handleSearchKeypress(event) {
            if (event.key === 'Enter') {
                searchCards();
            }
        }

        async function searchCards() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) {
                showMessage('Please enter a card name to search', 'warning');
                return;
            }

            showLoading(true);
            
            try {
                // Use exact name search to get all printings of a card
                const response = await fetch(`https://api.scryfall.com/cards/search?q=!"${encodeURIComponent(query)}"&unique=prints&order=released`, {
                    headers: {
                        'User-Agent': 'TCGCardManager/2.0'
                    }
                });

                if (!response.ok) {
                    // If exact search fails, fall back to fuzzy search
                    const fallbackResponse = await fetch(`https://api.scryfall.com/cards/search?q=${encodeURIComponent(query)}&unique=prints&order=released`, {
                        headers: {
                            'User-Agent': 'TCGCardManager/2.0'
                        }
                    });
                    
                    if (!fallbackResponse.ok) {
                        throw new Error(`Search failed: ${fallbackResponse.status}`);
                    }
                    
                    const fallbackData = await fallbackResponse.json();
                    searchResults = fallbackData.data || [];
                } else {
                    const data = await response.json();
                    searchResults = data.data || [];
                }
                
                displaySearchResults(searchResults);
                
            } catch (error) {
                console.error('Search error:', error);
                showMessage('Search failed. Please try again.', 'danger');
                displaySearchResults([]);
            } finally {
                showLoading(false);
            }
        }

        function displaySearchResults(results) {
            const container = document.getElementById('searchResults');
            
            // Filter to only paper cards
            const paperCards = results.filter(card => 
                !card.games || card.games.includes('paper')
            );
            
            if (paperCards.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-search-minus"></i>
                        <h5>No paper cards found</h5>
                        <p>Try a different search term or check if the card exists in paper format</p>
                    </div>
                `;
                return;
            }

            // Group cards by name to show different sets
            const cardGroups = {};
            paperCards.forEach(card => {
                if (!cardGroups[card.name]) {
                    cardGroups[card.name] = [];
                }
                cardGroups[card.name].push(card);
            });

            container.innerHTML = Object.entries(cardGroups).slice(0, 10).map(([cardName, cards]) => {
                // Sort cards by release date (newer first)
                const sortedCards = cards.sort((a, b) => {
                    const dateA = new Date(a.released_at || '1900-01-01');
                    const dateB = new Date(b.released_at || '1900-01-01');
                    return dateB - dateA;
                });

                // Group by set name
                const setGroups = {};
                sortedCards.forEach(card => {
                    if (!setGroups[card.set_name]) {
                        setGroups[card.set_name] = [];
                    }
                    setGroups[card.set_name].push(card);
                });

                const defaultCard = sortedCards[0];
                const cleanName = cardName.replace(/[^a-zA-Z0-9]/g, '');

                // Use utility functions for collector number logic
                const defaultSetCards = setGroups[defaultCard.set_name];
                const collectorGroups = deduplicateFoilVariants(defaultSetCards);
                const representativeCard = getRepresentativeCard(collectorGroups[Object.keys(collectorGroups)[0]]);

                return `
                    <div class="card mb-3">
                        <div class="card-body">
                            <div class="row align-items-center">
                                <div class="col-2">
                                    <img src="${defaultCard.image_uris?.small || ''}" alt="${cardName}" 
                                         style="width: 80px; height: auto; border-radius: 4px; cursor: pointer;"
                                         onclick="showLargeCardView('${defaultCard.id}')"
                                         id="card-image-${cleanName}">
                                </div>
                                <div class="col-3">
                                    <h6 class="mb-1">${cardName}</h6>
                                    <small class="text-muted">${defaultCard.type_line}</small>
                                </div>
                                <div class="col-2">
                                    <small class="text-muted d-block">Set</small>
                                    <select class="form-select form-select-sm" id="set-${cleanName}" onchange="updateCardVersion('${cardName}', this.value)">
                                        ${generateSetDropdown(cardName, setGroups)}
                                    </select>
                                </div>
                                <div class="col-2">
                                    <div id="collector-container-${cleanName}">
                                        <small class="text-muted d-block">Collector #</small>
                                        ${generateCollectorNumberDropdown(cardName, defaultSetCards, cleanName)}
                                    </div>
                                </div>
                                <div class="col-3">
                                    <div class="d-flex align-items-center gap-2">
                                        <div class="text-center">
                                            <select class="form-select form-select-sm condition-select mb-1" id="condition-${cleanName}">
                                                <option value="Near Mint">Near Mint</option>
                                                <option value="Lightly Played">Lightly Played</option>
                                                <option value="Moderately Played">Moderately Played</option>
                                                <option value="Heavily Played">Heavily Played</option>
                                            </select>
                                        </div>
                                        <div class="text-center">
                                            <button class="btn btn-sm btn-outline-warning" onclick="addCardToInventory('${cardName}', 'foil')">
                                                <i class="fas fa-star"></i>
                                            </button>
                                            <div class="small">Foil: <span id="foil-qty-${cleanName}">${getInventoryQuantity(cardName, 'foil', defaultCard.set_name, defaultCard.collector_number)}</span></div>
                                        </div>
                                        <div class="text-center">
                                            <button class="btn btn-sm btn-outline-primary" onclick="addCardToInventory('${cardName}', 'normal')">
                                                <i class="fas fa-plus"></i>
                                            </button>
                                            <div class="small">Normal: <span id="normal-qty-${cleanName}">${getInventoryQuantity(cardName, 'normal', defaultCard.set_name, defaultCard.collector_number)}</span></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Store all paper cards for reference
            window.allSearchResults = paperCards;
        }

        // ===== PHASE 2: CORE INVENTORY MATCHING =====
        
        /**
         * Core inventory matching function - finds all inventory matches for a card
         * @param {string} cardName - Card name to search for
         * @param {string} setName - Set name (optional)
         * @param {string} collectorNumber - Collector number (optional)
         * @param {string} finish - 'foil' or 'normal' (optional, if not specified returns both)
         * @returns {Array} - Array of matching inventory items
         */
        function findInventoryMatches(cardName, setName = null, collectorNumber = null, finish = null) {
            console.log(`ðŸ” Core search: "${cardName}" | "${setName}" | #${collectorNumber} | ${finish || 'any'}`);
            
            // Get all items with matching name and positive quantity
            const allNameMatches = inventory.filter(item => 
                item.name.toLowerCase() === cardName.toLowerCase() && item.quantity > 0
            );
            
            if (allNameMatches.length === 0) {
                console.log('âŒ No name matches found');
                return [];
            }
            
            // If no set/collector info provided, return all name matches (legacy compatibility)
            if (!setName || !collectorNumber) {
                console.log(`âœ… Returning ${allNameMatches.length} name-only matches (no set/collector specified)`);
                return filterByFinish(allNameMatches, finish);
            }
            
            const cleanCollectorNumber = String(collectorNumber).trim();
            
            // Strategy 1: Exact match (set + name + collector number)
            const exactMatches = allNameMatches.filter(item => 
                item.set === setName && String(item.number) === cleanCollectorNumber
            );
            
            if (exactMatches.length > 0) {
                console.log(`âœ… Found ${exactMatches.length} exact matches`);
                return filterByFinish(exactMatches, finish);
            }
            
            // Strategy 2: Set variations + name + collector number
            const setVariations = generateSetVariations(setName);
            
            if (setVariations.length > 0) {
                console.log(`ðŸ”„ Trying set variations: ${setVariations.join(', ')}`);
                const variationMatches = allNameMatches.filter(item => 
                    setVariations.includes(item.set) && String(item.number) === cleanCollectorNumber
                );
                
                if (variationMatches.length > 0) {
                    console.log(`âœ… Found ${variationMatches.length} variation matches`);
                    return filterByFinish(variationMatches, finish);
                }
            }
            
            // Strategy 3: Name + collector number only (any set) - but clean the collector number first
            const baseCollectorNumber = getBaseCollectorNumber(collectorNumber);
            const numberMatches = allNameMatches.filter(item => {
                const itemBaseNumber = getBaseCollectorNumber(item.number);
                return itemBaseNumber === baseCollectorNumber;
            });
            
            if (numberMatches.length > 0) {
                console.log(`âœ… Found ${numberMatches.length} number-only matches (base: ${baseCollectorNumber})`);
                return filterByFinish(numberMatches, finish);
            }
            
            // Strategy 4: No match found - return empty array (don't fall back to name-only)
            console.log(`âŒ No matches found for specific set/collector combination`);
            return [];
        }
        
        /**
         * Detect if a condition string indicates a foil card
         * @param {string} condition - Condition string (e.g., "Near Mint Foil", "Near Mint Foil - Portuguese")
         * @returns {boolean} - True if foil, false otherwise
         */
        function isFoilCondition(condition) {
            if (!condition) return false;
            return condition.toLowerCase().includes('foil');
        }

        /**
         * Get the base condition without foil or language modifiers
         * @param {string} condition - Full condition string
         * @returns {string} - Base condition (e.g., "Near Mint")
         */
        function getBaseCondition(condition) {
            if (!condition) return 'Near Mint';
            
            // Remove " Foil" and everything after it (including language)
            return condition.replace(/\s+foil.*$/i, '').trim() || 'Near Mint';
        }

        /**
         * Filter inventory matches by finish (foil/normal)
         * @param {Array} matches - Array of inventory items
         * @param {string} finish - 'foil' or 'normal' (null = return all)
         * @returns {Array} - Filtered inventory items
         */
        function filterByFinish(matches, finish) {
            if (!finish) return matches;
            
            if (finish === 'foil') {
                return matches.filter(item => isFoilCondition(item.condition));
            } else {
                return matches.filter(item => !isFoilCondition(item.condition));
            }
        }

        function getInventoryQuantity(cardName, finish, setName = null, collectorNumber = null) {
            // Use core matching function
            const matches = findInventoryMatches(cardName, setName, collectorNumber, finish);
            return matches.reduce((total, item) => total + item.quantity, 0);
        }

        function getInventoryCountForCardAndFinish(cardName, setName, collectorNumber, finish) {
            // Use core matching function
            const matches = findInventoryMatches(cardName, setName, collectorNumber, finish);
            return matches.reduce((total, item) => total + item.quantity, 0);
        }

        function hasInventoryForCard(cardName, setName, collectorNumber) {
            // Use core matching function - check for ANY finish
            const matches = findInventoryMatches(cardName, setName, collectorNumber);
            return matches.length > 0;
        }

        function getInventoryCountForCard(cardName, setName, collectorNumber) {
            // This function should count BOTH foil and non-foil versions
            // since they're the same card, just different finishes
            const matches = findInventoryMatches(cardName, setName, collectorNumber);
            return matches.reduce((total, item) => total + item.quantity, 0);
        }

        // ===== PHASE 3: DISPLAY LOGIC HELPERS =====
        
        /**
         * Generate collector number dropdown HTML for a set of cards
         * @param {string} cardName - Card name
         * @param {Array} setCards - Cards from the same set
         * @param {string} cleanName - Sanitized card name for IDs
         * @returns {string} - HTML for collector number dropdown or span
         */
        function generateCollectorNumberDropdown(cardName, setCards, cleanName) {
            const collectorGroups = deduplicateFoilVariants(setCards);
            const uniqueCollectorNumbers = Object.keys(collectorGroups);
            const hasMultipleCollectorNumbers = uniqueCollectorNumbers.length > 1;
            
            if (!hasMultipleCollectorNumbers) {
                // Single collector number - show as span
                const representativeCard = getRepresentativeCard(collectorGroups[uniqueCollectorNumbers[0]]);
                const baseNumber = getBaseCollectorNumber(representativeCard.collector_number);
                const hasInventory = hasInventoryForCard(cardName, representativeCard.set_name, representativeCard.collector_number);
                const count = getInventoryCountForCard(cardName, representativeCard.set_name, representativeCard.collector_number);
                const displayText = hasInventory ? `${baseNumber || 'N/A'} âœ“ (${count})` : (baseNumber || 'N/A');
                
                return `<span id="collector-span-${cleanName}" ${hasInventory ? 'style="color: #155724; font-weight: bold;"' : ''}>${displayText}</span>`;
            }
            
            // Multiple collector numbers - show as dropdown
            const options = uniqueCollectorNumbers.map(baseNumber => {
                const repCard = getRepresentativeCard(collectorGroups[baseNumber]);
                const hasInventory = hasInventoryForCard(cardName, repCard.set_name, repCard.collector_number);
                const count = getInventoryCountForCard(cardName, repCard.set_name, repCard.collector_number);
                const displayText = hasInventory ? `${baseNumber || 'N/A'} âœ“ (${count})` : (baseNumber || 'N/A');
                
                return `<option value="${repCard.id}" ${hasInventory ? 'style="background-color: #d4edda; font-weight: bold;"' : ''}>${displayText}</option>`;
            }).join('');
            
            return `
                <small class="text-muted d-block">Collector #</small>
                <select class="form-select form-select-sm" id="collector-${cleanName}" onchange="updateCollectorNumber('${cardName}', this.value)">
                    ${options}
                </select>
            `;
        }
        
        /**
         * Generate set dropdown HTML for a card
         * @param {string} cardName - Card name
         * @param {Object} setGroups - Object with set names as keys, card arrays as values
         * @returns {string} - HTML for set dropdown options
         */
        function generateSetDropdown(cardName, setGroups) {
            return Object.entries(setGroups).map(([setName, setCards]) => {
                const hasInventory = setCards.some(card => hasInventoryForCard(cardName, setName, card.collector_number));
                const totalCount = setCards.reduce((sum, card) => sum + getInventoryCountForCard(cardName, setName, card.collector_number), 0);
                const displayText = hasInventory ? `${setName} âœ“ (${totalCount})` : setName;
                
                return `<option value="${setCards[0].id}" data-set-name="${setName}" ${hasInventory ? 'style="background-color: #d4edda; font-weight: bold;"' : ''}>${displayText}</option>`;
            }).join('');
        }

        function getCurrentlySelectedCard(cardName) {
            const cleanName = cardName.replace(/[^a-zA-Z0-9]/g, '');
            
            // Check if there's a collector number dropdown
            const collectorSelect = document.getElementById(`collector-${cleanName}`);
            if (collectorSelect) {
                // Use collector dropdown selection
                return window.allSearchResults.find(c => c.id === collectorSelect.value);
            } else {
                // Use set dropdown selection
                const setSelect = document.getElementById(`set-${cleanName}`);
                return window.allSearchResults.find(c => c.id === setSelect.value);
            }
        }

        function updateCardVersion(cardName, cardId) {
            const card = window.allSearchResults.find(c => c.id === cardId);
            if (!card) return;
            
            const cleanName = cardName.replace(/[^a-zA-Z0-9]/g, '');
            
            // Update card image
            const imgElement = document.getElementById(`card-image-${cleanName}`);
            if (imgElement && card.image_uris?.small) {
                imgElement.src = card.image_uris.small;
                imgElement.onclick = () => showLargeCardView(card.id);
            }
            
            // Get all cards from the same set
            const setCards = window.allSearchResults.filter(c => 
                c.name === cardName && c.set_name === card.set_name
            );
            
            // Update collector number section using utility functions
            const collectorContainer = document.getElementById(`collector-container-${cleanName}`);
            collectorContainer.innerHTML = `
                <small class="text-muted d-block">Collector #</small>
                ${generateCollectorNumberDropdown(cardName, setCards, cleanName)}
            `;
            
            // Update quantity displays for the new version
            updateQuantityDisplays(cardName);
        }

        function updateCollectorNumber(cardName, cardId) {
            const card = window.allSearchResults.find(c => c.id === cardId);
            if (!card) return;
            
            const cleanName = cardName.replace(/[^a-zA-Z0-9]/g, '');
            
            // Update card image
            const imgElement = document.getElementById(`card-image-${cleanName}`);
            if (imgElement && card.image_uris?.small) {
                imgElement.src = card.image_uris.small;
                imgElement.onclick = () => showLargeCardView(card.id);
            }
            
            // Update quantity displays for the new version
            updateQuantityDisplays(cardName);
        }

        function showLargeCardView(cardId) {
            const card = window.allSearchResults.find(c => c.id === cardId);
            if (!card) return;
            
            // Create modal for large card view
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.id = 'cardModal';
            modal.innerHTML = `
                <div class="modal-dialog modal-lg" style="max-height: 80vh; margin: 1.75rem auto;">
                    <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h5 class="modal-title">${card.name}</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body text-center">
                            <img src="${card.image_uris?.large || card.image_uris?.normal || card.image_uris?.small || ''}" 
                                 alt="${card.name}" style="max-width: 100%; max-height: 60vh; height: auto; border-radius: 8px;">
                            <div class="mt-3">
                                <p><strong>Set:</strong> ${card.set_name}</p>
                                <p><strong>Collector #:</strong> ${card.collector_number || 'N/A'}</p>
                                <p><strong>Rarity:</strong> ${card.rarity}</p>
                                <p><strong>Type:</strong> ${card.type_line}</p>
                                ${card.mana_cost ? `<p><strong>Mana Cost:</strong> ${card.mana_cost}</p>` : ''}
                                ${card.oracle_text ? `<p><strong>Text:</strong> ${card.oracle_text}</p>` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove existing modal if present
            const existingModal = document.getElementById('cardModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            document.body.appendChild(modal);
            
            // Show modal using Bootstrap
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
            
            // Clean up when modal is hidden
            modal.addEventListener('hidden.bs.modal', () => {
                modal.remove();
            });
        }

        function addCardToInventory(cardName, finish) {
            const cleanName = cardName.replace(/[^a-zA-Z0-9]/g, '');
            
            // Get the currently selected card
            let selectedCard;
            
            // Check if there's a collector number dropdown
            const collectorSelect = document.getElementById(`collector-${cleanName}`);
            if (collectorSelect) {
                // Use collector dropdown selection
                selectedCard = window.allSearchResults.find(c => c.id === collectorSelect.value);
            } else {
                // Use set dropdown selection
                const setSelect = document.getElementById(`set-${cleanName}`);
                selectedCard = window.allSearchResults.find(c => c.id === setSelect.value);
            }
            
            if (!selectedCard) {
                showMessage('Please select a card version first', 'warning');
                return;
            }

            // Get the selected condition from the form
            const conditionSelect = document.getElementById(`condition-${cleanName}`);
            let baseCondition = conditionSelect ? conditionSelect.value : 'Near Mint';
            const condition = finish === 'foil' ? `${baseCondition} Foil` : baseCondition;
            
            // Check if item already exists (same name, set, collector number, and condition)
            const existingItem = inventory.find(i => 
                i.name === selectedCard.name && 
                i.set === selectedCard.set_name && 
                i.number === selectedCard.collector_number &&
                i.condition === condition
            );

            if (existingItem) {
                existingItem.quantity += 1;
            } else {
                // Try to find pricing data for this card
                const pricingData = findCardPricing(selectedCard.name, selectedCard.set_name, condition);
                
                let calculatedPrice = 0;
                let marketPrice = 0;
                let lowPrice = 0;
                let lowShipping = 0;
                
                if (pricingData) {
                    marketPrice = pricingData.marketPrice;
                    lowPrice = pricingData.lowPrice;
                    lowShipping = pricingData.lowShipping;
                    
                    // Apply TCG pricing rules using the existing function
                    const priceItem = {
                        marketPrice: marketPrice,
                        lowPrice: lowPrice,
                        lowShipping: lowShipping
                    };
                    calculatedPrice = calculateTCGPrice(priceItem);
                    
                    console.log(`ðŸ’° Found pricing for ${selectedCard.name} (${condition}): Market $${marketPrice}, Calculated $${calculatedPrice}`);
                } else {
                    console.log(`âš ï¸ No pricing data found for ${selectedCard.name} (${condition})`);
                }
                
                const inventoryItem = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                    name: selectedCard.name,
                    set: selectedCard.set_name,
                    condition: condition,
                    quantity: 1,
                    price: calculatedPrice,
                    originalPrice: calculatedPrice,
                    calculatedPrice: calculatedPrice,
                    marketPrice: marketPrice,
                    lowPrice: lowPrice,
                    lowShipping: lowShipping,
                    rarity: selectedCard.rarity,
                    number: selectedCard.collector_number,
                    image: selectedCard.image_uris?.normal || selectedCard.image_uris?.large || ''
                };
                inventory.push(inventoryItem);
            }

            saveInventoryToStorage();
            updateInventoryDisplay();
            
            // Update the quantity display in search results for this specific card name
            updateQuantityDisplays(cardName);

            showMessage(`Added 1x ${selectedCard.name} (${selectedCard.set_name} #${selectedCard.collector_number}, ${condition}) to inventory`, 'success');
        }

        function updateQuantityDisplays(cardName) {
            const cleanName = cardName.replace(/[^a-zA-Z0-9]/g, '');
            const foilQtyElement = document.getElementById(`foil-qty-${cleanName}`);
            const normalQtyElement = document.getElementById(`normal-qty-${cleanName}`);
            
            // Get the currently selected card version
            const selectedCard = getCurrentlySelectedCard(cardName);
            
            if (selectedCard && foilQtyElement) {
                foilQtyElement.textContent = getInventoryQuantity(cardName, 'foil', selectedCard.set_name, selectedCard.collector_number);
            }
            if (selectedCard && normalQtyElement) {
                normalQtyElement.textContent = getInventoryQuantity(cardName, 'normal', selectedCard.set_name, selectedCard.collector_number);
            }
            
            // Also refresh the dropdown indicators
            refreshDropdownIndicators(cardName);
        }

        function refreshDropdownIndicators(cardName) {
            const cleanName = cardName.replace(/[^a-zA-Z0-9]/g, '');
            
            // Update set dropdown indicators
            const setSelect = document.getElementById(`set-${cleanName}`);
            if (setSelect) {
                Array.from(setSelect.options).forEach(option => {
                    const setName = option.getAttribute('data-set-name');
                    if (setName) {
                        // Find cards for this set
                        const setCards = window.allSearchResults.filter(c => 
                            c.name === cardName && c.set_name === setName
                        );
                        
                        const hasInventory = setCards.some(card => hasInventoryForCard(cardName, setName, card.collector_number));
                        const totalCount = setCards.reduce((sum, card) => sum + getInventoryCountForCard(cardName, setName, card.collector_number), 0);
                        
                        if (hasInventory) {
                            option.textContent = `${setName} âœ“ (${totalCount})`;
                            option.style.backgroundColor = '#d4edda';
                            option.style.fontWeight = 'bold';
                        } else {
                            option.textContent = setName;
                            option.style.backgroundColor = '';
                            option.style.fontWeight = '';
                        }
                    }
                });
            }
            
            // Update collector dropdown indicators if present
            const collectorSelect = document.getElementById(`collector-${cleanName}`);
            if (collectorSelect) {
                Array.from(collectorSelect.options).forEach(option => {
                    const cardId = option.value;
                    const card = window.allSearchResults.find(c => c.id === cardId);
                    if (card) {
                        const hasInventory = hasInventoryForCard(cardName, card.set_name, card.collector_number);
                        const count = getInventoryCountForCard(cardName, card.set_name, card.collector_number);
                        
                        if (hasInventory) {
                            option.textContent = `${card.collector_number || 'N/A'} âœ“ (${count})`;
                            option.style.backgroundColor = '#d4edda';
                            option.style.fontWeight = 'bold';
                        } else {
                            option.textContent = card.collector_number || 'N/A';
                            option.style.backgroundColor = '';
                            option.style.fontWeight = '';
                        }
                    }
                });
            }
            
            // Update collector span if present
            const collectorSpan = document.getElementById(`collector-span-${cleanName}`);
            if (collectorSpan) {
                const selectedCard = getCurrentlySelectedCard(cardName);
                if (selectedCard) {
                    const hasInventory = hasInventoryForCard(cardName, selectedCard.set_name, selectedCard.collector_number);
                    const count = getInventoryCountForCard(cardName, selectedCard.set_name, selectedCard.collector_number);
                    
                    if (hasInventory) {
                        collectorSpan.textContent = `${selectedCard.collector_number || 'N/A'} âœ“ (${count})`;
                        collectorSpan.style.color = '#155724';
                        collectorSpan.style.fontWeight = 'bold';
                    } else {
                        collectorSpan.textContent = selectedCard.collector_number || 'N/A';
                        collectorSpan.style.color = '';
                        collectorSpan.style.fontWeight = '';
                    }
                }
            }
        }

        /**
         * Sort inventory by specified field and direction
         * @param {string} field - Field to sort by
         * @param {string} direction - 'asc' or 'desc'
         * @returns {Array} - Sorted inventory array
         */
        function sortInventory(field, direction = 'asc') {
            return [...inventory].sort((a, b) => {
                let aVal = a[field];
                let bVal = b[field];
                
                // Handle special cases
                if (field === 'foil') {
                    aVal = isFoilCondition(a.condition) ? 1 : 0;
                    bVal = isFoilCondition(b.condition) ? 1 : 0;
                } else if (field === 'condition') {
                    aVal = getBaseCondition(a.condition);
                    bVal = getBaseCondition(b.condition);
                } else if (typeof aVal === 'string') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                } else if (typeof aVal === 'number') {
                    aVal = aVal || 0;
                    bVal = bVal || 0;
                }
                
                if (direction === 'asc') {
                    return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                } else {
                    return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                }
            });
        }

        /**
         * Handle table header clicks for sorting
         * @param {string} field - Field to sort by
         */
        function handleSort(field) {
            if (currentSortField === field) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortField = field;
                currentSortDirection = 'asc';
            }
            
            updateInventoryDisplay();
            updateSortIcons();
        }

        /**
         * Update sort icons in table headers
         */
        function updateSortIcons() {
            // Reset all sort icons
            document.querySelectorAll('.sortable').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            
            // Set active sort icon
            const activeHeader = document.querySelector(`[data-sort="${currentSortField}"]`);
            if (activeHeader) {
                activeHeader.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
            }
        }

        function updateInventoryDisplay() {
            const tbody = document.getElementById('inventoryTableBody');
            const countBadge = document.getElementById('inventoryCount');
            
            if (inventory.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="12">
                            <div class="empty-state">
                                <i class="fas fa-box-open"></i>
                                <h5>No cards in inventory</h5>
                                <p>Search and add cards to get started</p>
                            </div>
                        </td>
                    </tr>
                `;
                countBadge.textContent = '0 cards';
                return;
            }

            // Sort inventory using current sort settings
            const sortedInventory = sortInventory(currentSortField, currentSortDirection);

            const totalCards = inventory.reduce((sum, item) => sum + item.quantity, 0);
            const totalValue = inventory.reduce((sum, item) => sum + ((item.calculatedPrice || item.price) * item.quantity), 0);
            
            countBadge.textContent = `${totalCards} cards â€¢ $${totalValue.toFixed(2)}`;

            tbody.innerHTML = sortedInventory.map(item => `
                <tr>
                    <td>${item.name}</td>
                    <td>${item.set}</td>
                    <td>${item.number || 'N/A'}</td>
                    <td>${getBaseCondition(item.condition)}</td>
                    <td>${isFoilCondition(item.condition) ? '<i class="fas fa-star text-warning"></i>' : ''}</td>
                    <td>
                        <input type="number" class="form-control form-control-sm" 
                               value="${item.quantity}" min="1" style="width: 80px;"
                               onchange="updateQuantity('${item.id}', this.value)">
                    </td>
                    <td>$${(item.marketPrice || 0).toFixed(2)}</td>
                    <td>$${(item.lowPrice || 0).toFixed(2)}</td>
                    <td>$${(item.lowShipping || 0).toFixed(2)}</td>
                    <td>
                        <input type="number" class="form-control form-control-sm" 
                               value="${item.originalPrice || item.price}" min="0" step="0.01" style="width: 100px;"
                               onchange="updateOriginalPrice('${item.id}', this.value)">
                    </td>
                    <td>$${(item.calculatedPrice || item.price).toFixed(2)}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-danger" onclick="removeFromInventory('${item.id}')">
                            <i class="fas fa-trash"></i>
                        </button>
                    </td>
                </tr>
            `).join('');
        }

        function updateQuantity(itemId, newQuantity) {
            const item = inventory.find(i => i.id === itemId);
            if (item) {
                item.quantity = parseInt(newQuantity) || 1;
                saveInventoryToStorage();
                updateInventoryDisplay();
            }
        }

        function updatePrice(itemId, newPrice) {
            const item = inventory.find(i => i.id === itemId);
            if (item) {
                item.price = roundPrice(newPrice);
                saveInventoryToStorage();
                updateInventoryDisplay();
            }
        }

        function updateOriginalPrice(itemId, newPrice) {
            const item = inventory.find(i => i.id === itemId);
            if (item) {
                item.originalPrice = roundPrice(newPrice);
                item.calculatedPrice = item.originalPrice; // Update calculated price too
                saveInventoryToStorage();
                updateInventoryDisplay();
            }
        }

        function calculateTCGPrice(item) {
            const MINIMUM_PRICE = 0.50;
            const marketPrice = item.marketPrice || 0;
            const lowPrice = item.lowPrice || 0;
            const lowShipping = item.lowShipping || 0;
            
            let calculatedPrice;
            
            // Expensive Cards: TCG Low Price OR Market Price > $30
            if (lowPrice > 30 || marketPrice > 30) {
                // Keep the original Market Price (do not alter)
                calculatedPrice = marketPrice;
            } 
            // Cheap Cards: TCG Low Price â‰¤ $0.30
            else if (lowPrice <= 0.30) {
                // max($0.50, TCG Low Price)
                calculatedPrice = Math.max(MINIMUM_PRICE, lowPrice);
            } 
            // Standard Cards: $0.30 < TCG Low Price â‰¤ $30
            else {
                // max($0.50, max(TCG Low Price, average of (TCG Low Price With Shipping and TCG Market Price)))
                
                // Handle missing Market Price: if Market Price is 0/missing, use Low+Shipping as the average
                let average;
                if (marketPrice > 0) {
                    // Both values available: normal average
                    average = (lowShipping + marketPrice) / 2;
                } else {
                    // Market Price missing: use Low+Shipping as the comparison value
                    average = lowShipping;
                }
                
                calculatedPrice = Math.max(MINIMUM_PRICE, Math.max(lowPrice, average));
            }
            
            // Round to 2 decimal places
            return Math.round(calculatedPrice * 100) / 100;
        }

        function updateAllPrices() {
            let updatedCount = 0;
            
            inventory.forEach(item => {
                // Only update if we have the necessary pricing data
                if (item.marketPrice && item.lowPrice && item.lowShipping) {
                    const newPrice = calculateTCGPrice(item);
                    if (newPrice !== item.calculatedPrice) {
                        item.calculatedPrice = newPrice;
                        updatedCount++;
                    }
                }
            });
            
            if (updatedCount > 0) {
                saveInventoryToStorage();
                updateInventoryDisplay();
                showMessage(`Updated prices for ${updatedCount} cards using TCG pricing rules`, 'success');
            } else {
                showMessage('No cards were updated. Make sure your inventory has TCG pricing data.', 'warning');
            }
        }

        function removeFromInventory(itemId) {
            if (confirm('Are you sure you want to remove this card from your inventory?')) {
                inventory = inventory.filter(item => item.id !== itemId);
                saveInventoryToStorage();
                updateInventoryDisplay();
                showMessage('Card removed from inventory', 'info');
            }
        }

        // Storage functions
        function saveInventoryToStorage() {
            try {
                localStorage.setItem('tcg_inventory_v2', JSON.stringify(inventory));
            } catch (error) {
                console.error('Failed to save inventory:', error);
                showMessage('Failed to save inventory to local storage', 'warning');
            }
        }

        function loadInventoryFromStorage() {
            try {
                const saved = localStorage.getItem('tcg_inventory_v2');
                if (saved) {
                    inventory = JSON.parse(saved);
                }
            } catch (error) {
                console.error('Failed to load inventory:', error);
                inventory = [];
            }
        }

        // Import/Export functions
        function importInventory() {
            const modal = new bootstrap.Modal(document.getElementById('importModal'));
            modal.show();
        }

        function processImport() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];
            const clearExisting = document.getElementById('clearExistingInventory').checked;
            
            if (!file) {
                showMessage('Please select a CSV file', 'warning');
                return;
            }

            // Clear existing inventory if requested
            if (clearExisting) {
                inventory = [];
            }

            // Use Papa Parse to handle all CSV complexity
            Papa.parse(file, {
                header: true,           // Use first row as column headers
                skipEmptyLines: true,   // Skip empty rows
                dynamicTyping: true,    // Auto-convert numbers
                complete: function(results) {
                    try {
                        let imported = 0;
                        let skipped = 0;
                        
                        results.data.forEach((row, index) => {
                            // Detect if this is a TCG export format
                            const isTCGFormat = row['TCGplayer Id'] || row['Product Name'] || row['TCG Marketplace Price'];
                            
                            let name, set, condition, quantity, price;
                            
                            if (isTCGFormat) {
                                // TCG Export Format - capture ALL data for round-trip compatibility
                                name = row['Product Name'] || row['Title'] || row['name'];
                                set = row['Set Name'] || row['set'];
                                condition = row['Condition'] || 'Near Mint';
                                quantity = parseInt(row['Total Quantity'] || row['quantity'] || 0);
                                price = roundPrice(row['TCG Marketplace Price'] || row['price'] || 0);
                                
                                // Additional pricing data for full table
                                const marketPrice = roundPrice(row['TCG Market Price'] || 0);
                                const lowPrice = roundPrice(row['TCG Low Price'] || 0);
                                const lowShipping = roundPrice(row['TCG Low Price With Shipping'] || 0);
                                
                                // Only import cards with quantity > 0
                                if (quantity <= 0) {
                                    skipped++;
                                    return;
                                }
                                
                                const item = {
                                    id: Date.now().toString() + '_' + index,
                                    cardId: 'imported_' + index,
                                    name: name,
                                    set: set || 'Unknown Set',
                                    condition: condition,
                                    quantity: quantity,
                                    price: price,
                                    marketPrice: marketPrice,
                                    lowPrice: lowPrice,
                                    lowShipping: lowShipping,
                                    originalPrice: price, // Store original marketplace price
                                    calculatedPrice: price, // For now, same as original
                                    imageUrl: '',
                                    // Store ALL original TCG data for export
                                    tcgplayerId: row['TCGplayer Id'] || '',
                                    productLine: row['Product Line'] || 'Magic',
                                    title: row['Title'] || name,
                                    number: row['Number'] || '',
                                    rarity: row['Rarity'] || '',
                                    tcgDirectLow: row['TCG Direct Low'] || '',
                                    addToQuantity: parseInt(row['Add to Quantity'] || 0),
                                    photoUrl: row['Photo URL'] || ''
                                };
                                
                                inventory.push(item);
                                imported++;
                            } else {
                                // Standard format
                                name = row['Card Name'] || row['name'] || row['Name'] || row['Product Name'] || row['title'];
                                set = row['Set'] || row['set'] || row['Set Name'] || row['setName'];
                                condition = row['Condition'] || row['condition'] || 'Near Mint';
                                quantity = parseInt(row['Quantity'] || row['quantity'] || row['Total Quantity'] || 1);
                                price = roundPrice(row['Price'] || row['price'] || 0);
                                
                                const item = {
                                    id: Date.now().toString() + '_' + index,
                                    cardId: 'imported_' + index,
                                    name: name,
                                    set: set || 'Unknown Set',
                                    condition: condition,
                                    quantity: quantity,
                                    price: price,
                                    marketPrice: price, // Use same price for all fields in standard format
                                    lowPrice: price,
                                    lowShipping: price,
                                    originalPrice: price,
                                    calculatedPrice: price,
                                    imageUrl: ''
                                };
                                
                                inventory.push(item);
                                imported++;
                            }
                        });
                        
                        saveInventoryToStorage();
                        updateInventoryDisplay();
                        bootstrap.Modal.getInstance(document.getElementById('importModal')).hide();
                        
                        const totalValue = inventory.reduce((sum, item) => sum + (item.price * item.quantity), 0);
                        showMessage(`Imported ${imported} cards (skipped ${skipped} with 0 quantity). Total value: $${totalValue.toFixed(2)}`, 'success');
                        
                    } catch (error) {
                        console.error('Import processing error:', error);
                        showMessage('Failed to process imported data: ' + error.message, 'danger');
                    }
                },
                error: function(error) {
                    console.error('CSV parsing error:', error);
                    showMessage('Failed to parse CSV file: ' + error.message, 'danger');
                }
            });
        }

        function exportInventory() {
            if (inventory.length === 0) {
                showMessage('No inventory to export', 'warning');
                return;
            }

            // Filter out cards with quantity = 0 (Inventory Export Rule)
            const exportableInventory = inventory.filter(item => item.quantity > 0);
            
            if (exportableInventory.length === 0) {
                showMessage('No cards with quantity > 0 to export', 'warning');
                return;
            }

            // Use TCG export format headers (same as imported CSV)
            const csvData = exportableInventory.map(item => ({
                'TCGplayer Id': item.tcgplayerId || '',
                'Product Line': item.productLine || 'Magic',
                'Set Name': item.set,
                'Product Name': item.name,
                'Title': item.title || item.name,
                'Number': item.number || '',
                'Rarity': item.rarity || '',
                'Condition': item.condition,
                'TCG Market Price': roundPrice(item.marketPrice || 0),
                'TCG Direct Low': item.tcgDirectLow || '',
                'TCG Low Price With Shipping': roundPrice(item.lowShipping || 0),
                'TCG Low Price': roundPrice(item.lowPrice || 0),
                'Total Quantity': item.quantity,
                'Add to Quantity': item.addToQuantity || 0,
                'TCG Marketplace Price': roundPrice(item.calculatedPrice || item.originalPrice || item.price),
                'Photo URL': item.photoUrl || ''
            }));

            const csv = Papa.unparse(csvData, {
                header: true,
                quotes: true  // Always quote fields to handle commas/quotes in card names
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `updated_inventory_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showMessage(`Inventory exported successfully (${exportableInventory.length} cards with quantity > 0)`, 'success');
        }

        function importInventory() {
            // Show the import modal
            const importModal = new bootstrap.Modal(document.getElementById('importModal'));
            importModal.show();
        }

        function importPrices() {
            // Create file input for price data
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const csvData = e.target.result;
                            const lines = csvData.split('\n');
                            const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
                            
                            priceData = [];
                            
                            for (let i = 1; i < lines.length; i++) {
                                const line = lines[i].trim();
                                if (!line) continue;
                                
                                const values = parseCSVLine(line);
                                if (values.length < headers.length) continue;
                                
                                const row = {};
                                headers.forEach((header, index) => {
                                    row[header] = values[index] || '';
                                });
                                
                                // Only add rows with valid pricing data
                                if (row['Product Name'] && row['TCG Market Price']) {
                                    priceData.push(row);
                                }
                            }
                            
                            showMessage(`Successfully imported ${priceData.length} price entries`, 'success');
                            console.log(`ðŸ“Š Imported ${priceData.length} price entries`);
                            
                            // Store in localStorage for persistence
                            try {
                                localStorage.setItem('tcg_price_data', JSON.stringify(priceData));
                            } catch (e) {
                                console.warn('Could not save price data to localStorage:', e);
                            }
                            
                        } catch (error) {
                            console.error('Error importing price data:', error);
                            showMessage('Error importing price data: ' + error.message, 'danger');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        // Load price data from localStorage on startup
        function loadPriceData() {
            try {
                const stored = localStorage.getItem('tcg_price_data');
                if (stored) {
                    priceData = JSON.parse(stored);
                    console.log(`ðŸ“Š Loaded ${priceData.length} price entries from localStorage`);
                }
            } catch (e) {
                console.warn('Could not load price data from localStorage:', e);
                priceData = [];
            }
        }

        // Find pricing data for a card
        function findCardPricing(cardName, setName, condition) {
            if (!priceData || priceData.length === 0) {
                return null;
            }
            
            // Try exact match first
            let match = priceData.find(item => 
                item['Product Name'] === cardName && 
                item['Set Name'] === setName && 
                item['Condition'] === condition
            );
            
            if (match) {
                return {
                    marketPrice: parseFloat(match['TCG Market Price']) || 0,
                    lowPrice: parseFloat(match['TCG Low Price']) || 0,
                    lowShipping: parseFloat(match['TCG Low Price With Shipping']) || 0,
                    tcgDirectLow: parseFloat(match['TCG Direct Low']) || 0
                };
            }
            
            // Try fuzzy matching on card name if exact match fails
            match = priceData.find(item => 
                item['Product Name'].toLowerCase().includes(cardName.toLowerCase()) && 
                item['Set Name'] === setName && 
                item['Condition'] === condition
            );
            
            if (match) {
                return {
                    marketPrice: parseFloat(match['TCG Market Price']) || 0,
                    lowPrice: parseFloat(match['TCG Low Price']) || 0,
                    lowShipping: parseFloat(match['TCG Low Price With Shipping']) || 0,
                    tcgDirectLow: parseFloat(match['TCG Direct Low']) || 0
                };
            }
            
            return null;
        }

        // Utility functions
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        // Escaped quote
                        current += '"';
                        i++; // Skip next quote
                    } else {
                        // Toggle quote state
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of field
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            // Add the last field
            result.push(current.trim());
            
            return result;
        }

        function roundPrice(price) {
            return Math.round((parseFloat(price) || 0) * 100) / 100;
        }

        function showLoading(show) {
            const spinner = document.getElementById('loadingSpinner');
            if (show) {
                spinner.classList.add('show');
            } else {
                spinner.classList.remove('show');
            }
        }

        function showMessage(message, type = 'info') {
            // Create toast notification
            const toast = document.createElement('div');
            toast.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
            toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
            toast.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(toast);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 5000);
        }
    </script>
</body>
</html>
